{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nexports.setField = setField;\nexports.registerOptionField = registerOptionField;\nexports.setOptionField = setOptionField;\nexports.isFieldValid = isFieldValid;\nexports.getFieldInvalidHint = getFieldInvalidHint;\nexports.isFieldVisiblyInvalid = isFieldVisiblyInvalid;\nexports.showInvalidField = showInvalidField;\nexports.hideInvalidFields = hideInvalidFields;\nexports.setFieldShowInvalid = setFieldShowInvalid;\nexports.clearFields = clearFields;\nexports.getField = getField;\nexports.getFieldValue = getFieldValue;\nexports.getFieldLabel = getFieldLabel;\nexports.phoneNumber = phoneNumber;\nexports.email = email;\nexports.vcode = vcode;\nexports.password = password;\nexports.username = username;\nexports.mfaCode = mfaCode;\nexports.isSelecting = isSelecting;\nexports.renderOptionSelection = renderOptionSelection;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _immutable = require('immutable');\n\nvar _trim = require('trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nvar _option_selection_pane = require('./option_selection_pane');\n\nvar _option_selection_pane2 = _interopRequireDefault(_option_selection_pane);\n\nvar _index = require('../core/index');\n\nvar l = _interopRequireWildcard(_index);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction setField(m, field, value) {\n  var validator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (str) {\n    return (0, _trim2.default)(str).length > 0;\n  };\n  var prevValue = m.getIn(['field', field, 'value']);\n  var prevShowInvalid = m.getIn(['field', field, 'showInvalid'], false);\n\n  for (var _len = arguments.length, args = Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {\n    args[_key - 4] = arguments[_key];\n  }\n\n  var validation = validate.apply(undefined, [validator, value].concat(args));\n  return m.mergeIn(['field', field], validation, (0, _immutable.Map)({\n    value: value,\n    showInvalid: prevShowInvalid && prevValue === value\n  }));\n}\n\nfunction validate(validator, value) {\n  if (typeof validator != 'function') return (0, _immutable.Map)({\n    valid: true\n  });\n\n  for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    args[_key2 - 2] = arguments[_key2];\n  }\n\n  var validation = validator.apply(undefined, [value].concat(args));\n  return validation && (typeof validation === 'undefined' ? 'undefined' : _typeof(validation)) === 'object' ? (0, _immutable.Map)({\n    valid: validation.valid,\n    invalidHint: validation.hint\n  }) : (0, _immutable.Map)({\n    valid: !!validation\n  });\n} // TODO: this should handle icons, and everything.\n// TODO: also there should be a similar fn for regular fields.\n\n\nfunction registerOptionField(m, field, options, initialValue) {\n  var valid = true,\n      hasInitial = !initialValue,\n      initialOption = void 0;\n  options.forEach(function (x) {\n    valid = valid && x.get('label') && typeof x.get('label') === 'string' && x.get('value') && typeof x.get('value') === 'string';\n\n    if (!hasInitial && x.get('value') === initialValue) {\n      initialOption = x;\n      hasInitial = true;\n    }\n  });\n\n  if (!valid || !options.size) {\n    var stopError = new Error('The options provided for the \"' + field + '\" field are invalid, they must have the following format: {label: \"non-empty string\", value: \"non-empty string\"} and there has to be at least one option.');\n    stopError.code = 'invalid_select_field'; // TODO: in the future we might want to return the result of the\n    // operation along with the model insteand of stopping the\n    // rendering, like [false, m] in the case of failure and [true, m]\n    // in the case of success.\n\n    return l.stop(m, stopError);\n  }\n\n  if (!initialOption) initialOption = (0, _immutable.Map)({});\n  return m.mergeIn(['field', field], initialOption, (0, _immutable.Map)({\n    options: options,\n    showInvalid: false,\n    valid: !initialOption.isEmpty()\n  }));\n}\n\nfunction setOptionField(m, field, option) {\n  return m.mergeIn(['field', field], option.merge((0, _immutable.Map)({\n    valid: true,\n    showInvalid: false\n  })));\n}\n\nfunction isFieldValid(m, field) {\n  return m.getIn(['field', field, 'valid']);\n}\n\nfunction getFieldInvalidHint(m, field) {\n  return m.getIn(['field', field, 'invalidHint'], '');\n}\n\nfunction isFieldVisiblyInvalid(m, field) {\n  return m.getIn(['field', field, 'showInvalid'], false) && !m.getIn(['field', field, 'valid']);\n}\n\nfunction showInvalidField(m, field) {\n  return m.setIn(['field', field, 'showInvalid'], !isFieldValid(m, field));\n}\n\nfunction hideInvalidFields(m) {\n  return m.update('field', function (fields) {\n    return fields && fields.map(function (field) {\n      return field.set('showInvalid', false);\n    });\n  });\n} // TODO: only used in passwordless, when we update it to use\n// validateAndSubmit this won't be needed anymore.\n\n\nfunction setFieldShowInvalid(m, field, value) {\n  return m.setIn(['field', field, 'showInvalid'], value);\n}\n\nfunction clearFields(m, fields) {\n  var keyPaths = void 0;\n\n  if (!fields || fields.length === 0) {\n    keyPaths = [['field']];\n  } else {\n    keyPaths = fields.map(function (x) {\n      return ['field', x];\n    });\n  }\n\n  return keyPaths.reduce(function (r, v) {\n    return r.removeIn(v);\n  }, m);\n}\n\nfunction getField(m, field) {\n  var notFound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _immutable.Map({});\n  return m.getIn(['field', field], notFound);\n}\n\nfunction getFieldValue(m, field) {\n  var notFound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return getField(m, field).get('value', notFound);\n}\n\nfunction getFieldLabel(m, field) {\n  var notFound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return getField(m, field).get('label', notFound);\n} // phone number\n\n\nfunction phoneNumber(lock) {\n  return lock.getIn(['field', 'phoneNumber', 'value'], '');\n} // email\n\n\nfunction email(m) {\n  return getFieldValue(m, 'email');\n} // vcode\n\n\nfunction vcode(m) {\n  return getFieldValue(m, 'vcode');\n} // password\n\n\nfunction password(m) {\n  return getFieldValue(m, 'password');\n} // username\n\n\nfunction username(m) {\n  return getFieldValue(m, 'username');\n} // mfa_code\n\n\nfunction mfaCode(m) {\n  return getFieldValue(m, 'mfa_code');\n} // select field options\n\n\nfunction isSelecting(m) {\n  return !!m.getIn(['field', 'selecting']);\n}\n\nfunction renderOptionSelection(m) {\n  var name = m.getIn(['field', 'selecting', 'name']);\n  return isSelecting(m) ? _react2.default.createElement(_option_selection_pane2.default, {\n    model: m,\n    name: name,\n    icon: m.getIn(['field', 'selecting', 'icon']),\n    iconUrl: m.getIn(['field', 'selecting', 'iconUrl']),\n    items: m.getIn(['field', name, 'options'])\n  }) : null;\n}","map":null,"metadata":{},"sourceType":"script"}