{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.go = undefined;\nexports.isSuccess = isSuccess;\nexports.isDone = isDone;\nexports.hasError = hasError;\n\nvar _immutable = require('immutable');\n\nvar _data_utils = require('./utils/data_utils');\n\nvar _index = require('./core/index');\n\nvar l = _interopRequireWildcard(_index);\n\nvar _index2 = require('./store/index');\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nvar _dataFns = (0, _data_utils.dataFns)(['sync']),\n    get = _dataFns.get,\n    set = _dataFns.set;\n\nexports.default = function (m, key, opts) {\n  if (get(m, key) !== undefined) return m;\n  var status = opts.waitFn ? 'waiting' : !opts.conditionFn || opts.conditionFn(m) ? 'pending' : 'no';\n  return set(m, key, (0, _immutable.Map)({\n    conditionFn: opts.conditionFn,\n    errorFn: opts.errorFn,\n    recoverResult: opts.recoverResult,\n    syncStatus: status,\n    successFn: opts.successFn,\n    syncFn: opts.syncFn,\n    timeout: opts.timeout || 6000,\n    waitFn: opts.waitFn\n  }));\n};\n\nvar syncStatusKey = function syncStatusKey(key) {\n  return (global.Array.isArray(key) ? key : [key]).concat(['syncStatus']);\n};\n\nvar getStatus = function getStatus(m, key) {\n  return get(m, syncStatusKey(key));\n};\n\nvar setStatus = function setStatus(m, key, str) {\n  return set(m, syncStatusKey(key), str);\n};\n\nvar getProp = function getProp(m, key, name) {\n  return get(m, key).get(name);\n};\n\nvar findKeys = function findKeys(m) {\n  return m.reduce(function (r, v, k) {\n    var current = _immutable.Map.isMap(v) && v.has('syncStatus') ? [k] : [];\n    var nested = _immutable.Map.isMap(v) ? findKeys(v).map(function (x) {\n      return [k].concat(x);\n    }) : [];\n    return r.concat.apply(r, [current].concat([nested]));\n  }, []);\n};\n\nfunction removeKeys(m, keys) {\n  return keys.reduce(function (r, k) {\n    return r.deleteIn(syncStatusKey(k));\n  }, m);\n}\n\nvar process = function process(m, id) {\n  var keys = findKeys(get(m, [], (0, _immutable.Map)())); // TODO timeout\n\n  return keys.reduce(function (r, k) {\n    if (typeof getProp(r, k, 'syncFn') != 'function') return r;\n\n    if (getStatus(r, k) === 'pending') {\n      r = setStatus(r, k, 'loading');\n      var called = false;\n      getProp(r, k, 'syncFn')(r, function (error, result) {\n        if (called) return;\n        called = true;\n        setTimeout(function () {\n          (0, _index2.swap)(_index2.updateEntity, 'lock', id, function (m) {\n            var errorFn = getProp(r, k, 'errorFn');\n\n            if (error && typeof errorFn === 'function') {\n              setTimeout(function () {\n                return errorFn(m, error);\n              }, 0);\n            }\n\n            var recoverResult = getProp(m, k, 'recoverResult');\n\n            if (error && recoverResult === undefined) {\n              return handleError(m, k, error);\n            } else {\n              m = setStatus(m, k, 'ok');\n              return getProp(m, k, 'successFn')(m, error ? recoverResult : result);\n            }\n          });\n        }, 0);\n      });\n    } else if (getStatus(r, k) === 'waiting') {\n      if (getProp(r, k, 'waitFn')(r)) {\n        var conditionFn = getProp(r, k, 'conditionFn');\n        r = setStatus(r, k, !conditionFn || conditionFn(r) ? 'pending' : 'no');\n      }\n    }\n\n    return r;\n  }, m);\n};\n\nvar go = exports.go = function go(id) {\n  (0, _index2.observe)('sync', id, function (m) {\n    setTimeout(function () {\n      return (0, _index2.swap)(_index2.updateEntity, 'lock', id, process, id);\n    }, 0);\n  });\n};\n\nfunction isSuccess(m, key) {\n  return getStatus(m, key) === 'ok';\n}\n\nfunction isDone(m) {\n  var keys = findKeys(get(m, [], (0, _immutable.Map)()));\n  return keys.length > 0 && keys.reduce(function (r, k) {\n    return r && !isLoading(m, k);\n  }, true);\n}\n\nfunction hasError(m) {\n  var excludeKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var keys = findKeys(removeKeys(get(m, [], (0, _immutable.Map)()), excludeKeys));\n  return keys.length > 0 && keys.reduce(function (r, k) {\n    return r || getStatus(m, k) === 'error';\n  }, false);\n}\n\nfunction isLoading(m, key) {\n  return ['loading', 'pending', 'waiting'].indexOf(getStatus(m, key)) > -1;\n}\n\nfunction handleError(m, key, error) {\n  var result = setStatus(m, key, 'error'); // TODO: this should be configurable for each sync\n\n  if (key !== 'sso') {\n    var stopError = new Error('An error occurred when fetching ' + key + ' data for Lock: ' + error.message);\n    stopError.code = 'sync';\n    stopError.origin = error;\n    result = l.stop(result, stopError);\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}