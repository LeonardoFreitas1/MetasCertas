'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = _lodash2.default.runInContext();

// Processes a ReactElement by iterating over its props, looking for
// props which are specified by `handlersToWrap`. Matching props will
// be passed to the derived class to be wrapped in a throttling function

var Base = function () {
  function Base(el, handlersToWrap, time) {
    var _this = this;

    _classCallCheck(this, Base);

    this.element = function () {
      return _this._el || (_this._el = _this._processElement());
    };

    this._processElement = function () {
      _this.handlers = _this._wrapHandlers();
      return _react2.default.cloneElement(_this.el, _this.handlers);
    };

    this._extractHandlers = function () {
      return _.pickBy(_this.el.props, _this._shouldWrapHandler);
    };

    this._wrapHandlers = function () {
      return _.mapValues(_this._extractHandlers(), _this._wrapHandler);
    };

    this._shouldWrapHandler = function (handler, handlerName) {
      return _.isFunction(handler) && _this.time > 0 && _this.handlersToWrap.includes(handlerName);
    };

    if (this.constructor === Base) {
      throw new Error('Can\'t instantiate abstract class!');
    }

    // Array of handler names which we should wrap
    this.handlersToWrap = handlersToWrap;

    // Throttle interval/delay
    this.time = time;

    // Element that we are processing
    this.el = el;

    // Array of handlers which we have wrapped (so we can unwrap them)
    this.handlers = [];
  }

  // How the processed element is made public, memoized


  // Clone the element, overwriting unwrapped handlers with their wrapped versions


  // Find the handlers which should be wrapped by the throttling function


  // Pass each handler to the derived class to be wrapped


  _createClass(Base, [{
    key: 'destroy',


    // Cancel timers related to throttling
    value: function destroy() {
      _.values(this.handlers).forEach(this._cancelThrottle);
    }

    // Lodash provides cancel methods on throttle/debounce wrappers

  }, {
    key: '_cancelThrottle',
    value: function _cancelThrottle(handler) {
      handler.cancel && handler.cancel();
    }
  }]);

  return Base;
}();

exports.default = Base;